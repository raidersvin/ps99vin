-- sau 3 tiếng đổi đến 1 sever vắng người chơi
task.spawn(function()

task.wait(10800)

local HttpService = game:GetService("HttpService")
local TeleportService = game:GetService("TeleportService")
local Player = game:GetService("Players").LocalPlayer
local mathRandom = math.random
local NetworkClient = game:GetService("NetworkClient")

-- Hàm kiểm tra ping của server (đây có thể là cách tạm thời, có thể cần chỉnh sửa tùy vào API của Roblox)
local function getServerPing(serverId)
    -- Giả sử chúng ta có thể lấy ping của server (lưu ý rằng đây chỉ là phương thức giả định, cần phải thay bằng cách thực tế để kiểm tra ping)
    -- Bạn có thể cần sử dụng dịch vụ khác để lấy ping thực sự, ví dụ như kiểm tra trạng thái kết nối của người chơi.
    return mathRandom(50, 150)  -- Ping giả định giữa 50ms và 150ms
end

local function teleportToMostPopulatedServer(placeId, retryLimit, userIdsToExclude)
    retryLimit = retryLimit or 5 -- Số lần thử lại mặc định là 5
    local attempts = 0
    local minPlayers = 1 -- Số lượng người chơi tối thiểu (ví dụ: 1 người)

    -- Lấy ID server hiện tại của người chơi
    local function getCurrentServerId()
        return game:GetService("Players").LocalPlayer.Team or "Unknown"  -- Mặc định là "Unknown" nếu không lấy được server ID
    end

    while attempts < retryLimit do
        attempts += 1
        local success, result = pcall(function()
            -- Lấy danh sách các server với sortOrder=Asc và excludeFullServers=true để lọc các server không đầy
            return HttpService:JSONDecode(game:HttpGet('https://games.roblox.com/v1/games/' .. placeId .. '/servers/Public?sortOrder=Asc&limit=100&excludeFullServers=true')).data
        end)

        if success and result and #result > 0 then
            -- Lọc các server hợp lệ có ít nhất minPlayers và không đầy
            local validServers = {}
            for _, server in ipairs(result) do
                -- Kiểm tra xem server có đủ người chơi và không đầy
                if server.playing >= minPlayers and server.playing < server.maxPlayers then
                    -- Kiểm tra xem server có chứa người chơi cần loại trừ không
                    local hasExcludedPlayer = false
                    for _, playerId in ipairs(server.players) do
                        if table.find(userIdsToExclude, playerId) then
                            hasExcludedPlayer = true
                            break
                        end
                    end

                    -- Nếu không có người chơi bị loại trừ, thêm vào danh sách server hợp lệ
                    if not hasExcludedPlayer then
                        -- Thêm server vào danh sách với giá trị ping của nó
                        table.insert(validServers, {
                            server = server,
                            ping = getServerPing(server.id)  -- Thêm giá trị ping vào
                        })
                    end
                end
            end

            -- Nếu có server hợp lệ, sắp xếp các server theo ping (từ thấp đến cao)
            if #validServers > 0 then
                table.sort(validServers, function(a, b)
                    return a.ping < b.ping  -- Sắp xếp theo ping (theo thứ tự tăng dần)
                end)

                -- Chọn server có ping thấp nhất (server đầu tiên trong danh sách đã sắp xếp)
                local serverToTeleport = validServers[1].server

                -- Teleport đến server đã chọn
                local teleportSuccess, teleportError = pcall(function()
                    TeleportService:TeleportToPlaceInstance(placeId, serverToTeleport.id, Player)
                end)

                if teleportSuccess then
                    print("Teleport thành công đến server:", serverToTeleport.id)
                    
                    -- Lưu lại ID server gốc trước khi teleport
                    local originalServerId = getCurrentServerId()

                    -- Chờ 3 giây và kiểm tra xem người chơi đã chuyển server chưa
                    task.wait(3)
                    
                    -- Kiểm tra lại xem người chơi có còn ở server gốc không
                    if getCurrentServerId() == originalServerId then
                        print("Không chuyển đến server mới, thử lại teleport...")
                        -- Nếu người chơi vẫn ở server cũ, thử teleport sang một server hợp lệ khác
                        table.remove(validServers, 1)  -- Loại bỏ server đầu tiên (server có ping thấp nhất)
                        if #validServers > 0 then
                            return teleportToMostPopulatedServer(placeId, retryLimit, userIdsToExclude)  -- Gọi lại hàm với server mới
                        else
                            print("Không còn server hợp lệ để thử teleport.")
                            return false
                        end
                    else
                        return true  -- Thành công khi chuyển đến server mới
                    end
                else
                    warn("Teleport thất bại, thử lại... (Lỗi: " .. tostring(teleportError) .. ")")
                end
            else
                print("Không có server hợp lệ!")
            end
        else
            warn("Không thể lấy danh sách server! Thử lại lần " .. attempts)
        end

        task.wait(2) -- Chờ trước khi thử lại
    end

    warn("Không thể teleport sau " .. retryLimit .. " lần thử!")
    return false
end

-- Danh sách các UserId cố định mà bạn muốn tránh
local userIdsToExclude = {

    7224796491
}

-- Gọi hàm với PlaceId cụ thể và danh sách các UserId bạn muốn tránh
task.wait(1)
teleportToMostPopulatedServer(140403681187145, 25, userIdsToExclude) -- Thử tối đa 25 lần



end)

-- thêm bạn bè
task.spawn(function()
	task.wait(300)

local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

for _, player in pairs(Players:GetPlayers()) do
    if player ~= LocalPlayer then
        pcall(function()
            LocalPlayer:RequestFriendship(player)
			task.wait(300)
        end)
    end
end

end)

-- Xem item cần tìm x 10 ở giữa cho giả lập

task.spawn(function()
	task.wait(1)

	local Players = game:GetService("Players")
	local ReplicatedStorage = game:GetService("ReplicatedStorage")

	local LocalPlayer = Players.LocalPlayer
	local PlayerGui = LocalPlayer:WaitForChild("PlayerGui")
	local Client = ReplicatedStorage:WaitForChild("Library"):WaitForChild("Client")
	local SaveModule = require(Client:WaitForChild("Save"))

	local previousCounts = {}

	-- cấu hình item cần theo dõi
	local itemsToTrack = {
		
		{ id = "MVP Key", guiName = "Item3", row = 1, col = 0, color = Color3.fromRGB(0, 255, 255) },					--xanh	trái
		{ id = "MVP Key Upper Half", guiName = "Item4", row = 1, col = 1, color = Color3.fromRGB(0, 255, 255) }, 		--xanh	phải
		{ id = "Fragmented Dominus Ball", guiName = "Item1", row = 0, col = 0, color = Color3.fromRGB(255, 165, 0) },	-- cam
		{ id = "Black Hole Angelus Ball", guiName = "Item2", row = 0, col = 1, color = Color3.fromRGB(255, 255, 255) },	--trang
	}

	local function createItemFrame(itemConfig, itemCount)
		local frameSize = 100
		local spacing = 10
		local cols = 2
		local rows = 2

		-- tính vị trí chính giữa màn hình
		local offsetX = (itemConfig.col * (frameSize + spacing)) - ((cols - 1) * (frameSize + spacing) / 2)
		local offsetY = (itemConfig.row * (frameSize + spacing)) - ((rows - 1) * (frameSize + spacing) / 2) + 80


		local screenGui = Instance.new("ScreenGui")
		screenGui.Name = itemConfig.guiName
		screenGui.Parent = PlayerGui
		screenGui.ResetOnSpawn = false
		screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling

		local frame = Instance.new("Frame")
		frame.Name = "ItemFrame"
		frame.Size = UDim2.new(0, frameSize, 0, frameSize)
		frame.Position = UDim2.new(0.5, offsetX, 1, -offsetY)
		frame.AnchorPoint = Vector2.new(0.5, 1)
		frame.BackgroundColor3 = itemConfig.color
		frame.BorderSizePixel = 2
		frame.Parent = screenGui

		local label = Instance.new("TextLabel")
		label.Size = UDim2.new(1, 0, 1, 0)
		label.BackgroundTransparency = 1
		label.Text = tostring(itemCount)
		label.TextColor3 = Color3.fromRGB(0, 0, 0)
		label.TextScaled = true
		label.Font = Enum.Font.GothamBold
		label.Parent = frame
	end

	local function checkInventory()
		local inventory = SaveModule.Get().Inventory or {}
		local currentCounts = {}

		-- xóa GUI cũ
		for _, item in ipairs(itemsToTrack) do
			local oldGui = PlayerGui:FindFirstChild(item.guiName)
			if oldGui then oldGui:Destroy() end
		end

		for _, item in ipairs(itemsToTrack) do
			local count = 0
			for _, group in pairs(inventory) do
				for _, obj in pairs(group) do
					if obj.id == item.id then
						count += (obj._am or 1)
					end
				end
			end
			currentCounts[item.id] = count
			createItemFrame(item, count)
		end

		previousCounts = currentCounts
	end

	checkInventory()
	while true do
		task.wait(10)
		checkInventory()
	end
end)




-- check toạ độ vs xút ra khi bị rơi
task.spawn(function()
	task.wait(150)
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

local player = Players.LocalPlayer

-- Tạo GUI hiển thị tọa độ
local screenGui = Instance.new("ScreenGui")
screenGui.Parent = player:WaitForChild("PlayerGui")

local coordLabel = Instance.new("TextLabel")
coordLabel.Size = UDim2.new(0, 400, 0, 50)
coordLabel.Position = UDim2.new(0.5, -200, 0.5, -25) -- Giữa màn hình
coordLabel.BackgroundTransparency = 0.4
coordLabel.BackgroundColor3 = Color3.new(0, 0, 0)
coordLabel.TextColor3 = Color3.new(1, 1, 1)
coordLabel.TextScaled = true
coordLabel.Font = Enum.Font.SourceSansBold
coordLabel.Text = "wait..."
coordLabel.Parent = screenGui

-- Cập nhật tọa độ nhân vật liên tục
RunService.RenderStepped:Connect(function()
    local character = player.Character
    if character and character:FindFirstChild("HumanoidRootPart") then
        local pos = character.HumanoidRootPart.Position
        coordLabel.Text = string.format(" X: %.1f | Y: %.1f | Z: %.1f", pos.X, pos.Y, pos.Z)
    else
        coordLabel.Text = "not find user!"
		game:Shutdown()  -- Thoát game
    end
end)


end)

-- Ghép chìa
task.spawn(function()
	task.wait(150)

local l_Save = require(game:GetService("ReplicatedStorage").Library.Client.Save)
local replicatedStorage = game:GetService("ReplicatedStorage")

local keyPairs = {
    ["Fantasy Key"] = {
        halves = {"Fantasy Key Lower Half", "Fantasy Key Upper Half"},
        combineFunction = "FantasyKey_Combine"
    },
    ["Tech Key"] = {
        halves = {"Tech Key Lower Half", "Tech Key Upper Half"},
        combineFunction = "TechKey_Combine"
    },
    ["Void Key"] = {
        halves = {"Void Key Lower Half", "Void Key Upper Half"},
        combineFunction = "VoidKey_Combine"
    },
    ["Secret Key"] = {
        halves = {"Secret Key Lower Half", "Secret Key Upper Half"},
        combineFunction = "SecretKey_Combine"
    },
    ["Crystal Key"] = {
        halves = {"Crystal Key Lower Half", "Crystal Key Upper Half"},
        combineFunction = "CrystalKey_Combine"
    }
}

local function checkKeys()
    local misc = l_Save.Get().Inventory.Misc
    local foundKeyHalves = {}

    for _, v in pairs(misc) do
        for _, data in pairs(keyPairs) do
            if v.id == data.halves[1] or v.id == data.halves[2] then
                foundKeyHalves[v.id] = v._am or 1
            end
        end
    end

    for _, data in pairs(keyPairs) do
        local half1 = foundKeyHalves[data.halves[1]] or 0
        local half2 = foundKeyHalves[data.halves[2]] or 0
        local combineCount = math.min(half1, half2)

        if combineCount >= 5 then
            local combineFunction = replicatedStorage.Network:FindFirstChild(data.combineFunction)
            if combineFunction then
                combineFunction:InvokeServer(5)
            end
        end
    end
end


    while true do
        checkKeys()
        task.wait(10) -- Điều chỉnh tần suất gọi nếu cần
    end


end)

-- Ghép sách + thuốc nếu lv < 99 
task.spawn(function()
	task.wait(150)
local Save = require(game:GetService("ReplicatedStorage").Library.Client.Save)
local level = Save.Get().Mastery and Save.Get().Mastery.Potions

if level and level < 13034430 then

    -- Hàm nâng cấp thuốc
    local function _update_sach_theo_level(name_sach, level_sach)
        local saveModule = require(game.ReplicatedStorage.Library.Client.Save)
        local inventory = saveModule.Get() and saveModule.Get().Inventory and saveModule.Get().Inventory.Potion
        if not inventory then return end

        local count = 0
        local uid_sach = nil

        for itemUID, itemData in pairs(inventory) do
            if itemData.id == name_sach and itemData.tn == level_sach then
                count += (itemData._am or 1)
                uid_sach = tostring(itemUID)
            end
        end

        local totalUpgradeAmount = count // 3
        if uid_sach and totalUpgradeAmount > 0 then
            game:GetService("ReplicatedStorage").Network.UpgradePotionsMachine_Activate:InvokeServer(uid_sach, totalUpgradeAmount)
            warn("Upgrade: " .. name_sach .. " UID : " .. uid_sach .. " x" .. totalUpgradeAmount .. "\n")
        end
    end

    -- Danh sách sách cần nâng cấp
    local list = {
        "Treasure Hunter", "Walkspeed", "Strong Pets", 
        "Lucky Eggs", "Diamonds", "Coins"
    }

    for _, name in ipairs(list) do
        _update_sach_theo_level(name, 1)
		task.wait(2)
        _update_sach_theo_level(name, 2)
		task.wait(2)
    end
	
end


-----------------------
local Save = require(game:GetService("ReplicatedStorage").Library.Client.Save)
local level = Save.Get().Mastery and Save.Get().Mastery.Enchants

if level and level < 13034430 then

    -- Hàm nâng cấp sách
    local function _update_sach_theo_level(name_sach, level_sach)
        local saveModule = require(game.ReplicatedStorage.Library.Client.Save)
        local inventory = saveModule.Get() and saveModule.Get().Inventory and saveModule.Get().Inventory.Enchant
        if not inventory then return end

        local count = 0
        local uid_sach = nil

        for itemUID, itemData in pairs(inventory) do
            if itemData.id == name_sach and itemData.tn == level_sach then
                count += (itemData._am or 1)
                uid_sach = tostring(itemUID)
            end
        end

        local totalUpgradeAmount = count // 5
        if uid_sach and totalUpgradeAmount > 0 then
            game:GetService("ReplicatedStorage").Network.UpgradeEnchantsMachine_Activate:InvokeServer(uid_sach, totalUpgradeAmount)
            warn("Upgrade: " .. name_sach .. " lv" .. level_sach .. " x" .. totalUpgradeAmount .. "\n")
        end
    end

    -- Danh sách sách cần nâng cấp
    local list = {
        "Treasure Hunter", "Tap Power", "Strong Pets", "Walkspeed",
        "Magnet", "Lucky Eggs", "Diamonds", "Criticals", "Coins"
    }

    for _, name in ipairs(list) do
        _update_sach_theo_level(name, 1)
		task.wait(2)
        _update_sach_theo_level(name, 2)
		task.wait(2)
    end
	
end

end)


local Players = game:GetService("Players")
local player = Players.LocalPlayer

while not player do
    task.wait(1)
    player = Players.LocalPlayer
end

local names = {"CircuitRid3r2019","N0vaBear200586","FrostStr3amHawk","Magic_Hyper2006","LegendOrbitNight","GlitchCraftDawn","Emma_HUNTER65","EzraWraith85","Jayd3nGalaxy69","XxGabrielBaneDancerx","StealthPowerFlame","ClawStorm2002","Nora_FLASH22","XxOrbitZer0GalaxyxX2","tethgarawi","karlo8266","parentenevzet95","mayenkahan93","pierautsundue86","fatmavandercr49","irgcoypusb","yantungleggatt63","menkoludzer79","vasanth59150","lavinie91258","heraldaleksand57","burchard6297","etwitepluffyx","muoininfaui","1941Dodds","1949McKnight3113","1952Fiore3116","1953Crutchfield3117","Hunt3rCrystalVoid","MagicPow3r63","Xx_VictoriaUltraCybe","EliMoonGolden","Inferno_Eagle200889","M00nSkaterNe0n","XxJacksonEchoxX2012","XxJackHeroxX2011","Turbo_Nova200314"}

local emails = {"mcconchifredjeyo","ecclweltst","killedsanthi85","tamuleviazulayv","hegemangaltieri81","fadile66096","sollarleats","bhosievvanister","pafnucymargit21","ghaldoun9247","feodslogeshy","holvastroaldf","bradodette49","34Jaret35","kapurvludi"}

local totalEmails = #emails
local groupSize = totalEmails
local found = false

for i = 1, #names do
    if player.Name == names[i] then
        local indexInGroup = ((i - 1) % groupSize) + 1
        getgenv().GMAIL_RECEIVERS = { tostring(emails[indexInGroup]) }
        found = true
        break
    end
end

if not found then
    --getgenv().GMAIL_RECEIVERS = {""}
    --warn("Tên người chơi không nằm trong danh sách hợp lệ.")
end

getgenv().GMAIL_ITEMS = {

	["MVP Key Upper Half"] = {Class = "Misc", Id = "MVP Key Upper Half", MinAmount = 10},	
	
}

script_key = "IAMAiZhmvPSarFAwYGimVtcLzrqIAnAQ";
--PS99 LOADER!!

			-- INSERT YOUR CONFIG HERE --
getgenv().GEVENT_FPS  = 5
getgenv().GGFX_MODE = 1
getgenv().GZONE_TO = 999

getgenv().GPROGRESS_MODE = "Hybrid"
getgenv().GRANK_TO = 99
getgenv().GZONE_TO = 999 
getgenv().GMAX_EGG_SLOTS = 99
getgenv().GMAX_EQUIP_SLOTS = 99
getgenv().GMAX_ZONE_UPGRADE_COST = 20000000
getgenv().GMASTERY_TO_MAX = "Pets"
getgenv().GEVENT_ITEMS_TO_USE = {"Mini Pinata","Party Box","Mini Lucky Block","Comet"}
getgenv().GUSE_SPRINKLERS = true 
getgenv().GUSE_FLAGS = {"Fortune Flag"}

getgenv().GPOTIONS = {"The Cocktail","Lucky","Treasure Hunter","Walkspeed","Diamonds","Damage"}
getgenv().GPOTIONS_MAX_TIER = 19

getgenv().GUSE_ULTIMATES = {"Tsunami","Tornado","Lightning Storm"}

getgenv().GENCHANTS = {"Breakable Mayhem","Lucky Eggs","Huge Hunter","Diamonds","Treasure Hunter","Explosive","Super Lightning","Diamonds","Large Taps"}

getgenv().GDAYCARE = true
getgenv().GHATCH_CHARGED_EGGS = false
getgenv().GCLEAR_FAVORITE_PETS = true

getgenv().GHOLD_GIFTS = false
getgenv().GHOLD_BUNDLES = false
getgenv().GLOOTBOXES = {"All"}
getgenv().GCONSUME_CHARMS = true
getgenv().GUSE_SPINNY_WHEEL = true
------------------------------------------------

getgenv().GAUTO_UPGRADE_PETS = true

-----------------------------------------------
getgenv().GHUGE_COUNT = 500



		-- INSERT YOUR CONFIG HERE --
loadstring(game:HttpGet("https://api.luarmor.net/files/v3/loaders/ba2dcad2127dcfc04301dfe52ce6c61c.lua"))()







